import html2pdf from 'html2pdf.js'

export function generateSessionReport(gameStore, alertsStore, ticketsStore, commsStore, evidenceStore) {
  const now = new Date()
  const scenario = gameStore.scenario
  
  // Get reactive values
  const channels = commsStore.channels
  const npcs = commsStore.npcs
  const ticketNotes = ticketsStore.ticketNotes
  const alertNotes = alertsStore.alertNotes
  const allTickets = ticketsStore.allTickets
  const allAlerts = alertsStore.allAlerts
  const unlockedEvidence = evidenceStore.unlockedEvidence
  const actionLog = gameStore.actionLog
  
  // Build timeline data structure
  const timeline = buildTimeline(actionLog, channels, npcs, ticketNotes, alertNotes, allTickets, allAlerts, unlockedEvidence)
  
  // Build HTML content
  const html = `
    <div style="font-family: 'Segoe UI', system-ui, sans-serif; color: #222; padding: 20px; max-width: 800px;">
      <!-- Header -->
      <div style="border-bottom: 3px solid #4a9eff; padding-bottom: 20px; margin-bottom: 30px;">
        <h1 style="margin: 0 0 5px 0; color: #1a1a2e; font-size: 28px;">
          ${scenario?.config.title || 'SOC Simulator'} ‚Äî Session Report
        </h1>
        <p style="margin: 0; color: #666; font-size: 14px;">
          ${scenario?.config.subtitle || ''}
        </p>
      </div>
      
      <!-- Session Summary -->
      <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 30px;">
        <h2 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">Session Summary</h2>
        <table style="width: 100%; font-size: 14px;">
          <tr>
            <td style="padding: 4px 0; color: #666;">Company:</td>
            <td style="padding: 4px 0;">${scenario?.config.company?.name || 'N/A'}</td>
            <td style="padding: 4px 0; color: #666;">Exported:</td>
            <td style="padding: 4px 0;">${now.toLocaleString('en-AU')}</td>
          </tr>
          <tr>
            <td style="padding: 4px 0; color: #666;">Scenario Date:</td>
            <td style="padding: 4px 0;">${scenario?.config.briefing?.date || 'N/A'}</td>
            <td style="padding: 4px 0; color: #666;">Time Remaining:</td>
            <td style="padding: 4px 0;">${gameStore.formattedTime}</td>
          </tr>
          <tr>
            <td style="padding: 4px 0; color: #666;">Tokens Used:</td>
            <td style="padding: 4px 0;">${(scenario?.config.tokens || 12) - gameStore.tokens} / ${scenario?.config.tokens || 12}</td>
            <td style="padding: 4px 0; color: #666;">Evidence Collected:</td>
            <td style="padding: 4px 0;">${unlockedEvidence.length} items</td>
          </tr>
        </table>
      </div>
      
      <!-- Timeline -->
      <div style="margin-bottom: 30px;">
        <h2 style="color: #1a1a2e; font-size: 18px; border-bottom: 2px solid #ddd; padding-bottom: 8px; margin-bottom: 20px;">
          Session Timeline
        </h2>
        ${timeline.map(entry => renderTimelineEntry(entry)).join('')}
      </div>
      
      <!-- Footer -->
      <div style="border-top: 1px solid #ddd; padding-top: 15px; margin-top: 30px; font-size: 11px; color: #999;">
        <p>Generated by SOC Simulator ‚Ä¢ ${now.toISOString()}</p>
      </div>
    </div>
  `
  
  // Configure PDF options
  const opt = {
    margin: [10, 10, 10, 10],
    filename: `session-report-${now.toISOString().slice(0, 10)}.pdf`,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: { scale: 2, useCORS: true },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
    pagebreak: { mode: ['avoid-all', 'css', 'legacy'] }
  }
  
  // Generate PDF
  const container = document.createElement('div')
  container.innerHTML = html
  
  return html2pdf().set(opt).from(container).save()
}

function buildTimeline(actionLog, channels, npcs, ticketNotes, alertNotes, allTickets, allAlerts, unlockedEvidence) {
  // Create a map of evidence by ID for quick lookup
  const evidenceMap = {}
  unlockedEvidence.forEach(ev => { evidenceMap[ev.id] = ev })
  
  // Create a map of messages by timestamp for matching
  const allMessages = []
  Object.entries(channels).forEach(([npcId, messages]) => {
    messages.forEach(msg => {
      allMessages.push({ ...msg, npcId, npc: npcs[npcId] })
    })
  })
  
  // Process action log in chronological order (oldest first)
  const chronologicalLog = [...actionLog].reverse()
  
  const timeline = []
  const usedMessageIds = new Set()
  const usedEvidenceIds = new Set()
  const usedNoteTicketIds = new Set()
  const usedNoteAlertIds = new Set()
  
  chronologicalLog.forEach(entry => {
    const timelineEntry = {
      type: entry.type,
      gameTime: entry.gameTime,
      realTime: new Date(entry.timestamp).toLocaleTimeString('en-AU'),
      message: entry.message,
      attachments: []
    }
    
    // Check if this action unlocked evidence
    if (entry.details?.unlocksEvidence) {
      const evId = entry.details.unlocksEvidence
      if (evidenceMap[evId] && !usedEvidenceIds.has(evId)) {
        timelineEntry.attachments.push({
          type: 'evidence',
          data: evidenceMap[evId]
        })
        usedEvidenceIds.add(evId)
      }
    }
    
    // Check if this is a comms action - attach the player message and response
    if (entry.type === 'comms' && entry.details?.content) {
      timelineEntry.attachments.push({
        type: 'player-message',
        content: entry.details.content
      })
    }
    
    // Check if this is an assessment result - find the NPC response that follows
    if (entry.type === 'assessment' && entry.message.includes('Escalation self-assessment')) {
      // Find NPC response message that came shortly after this
      const entryTime = new Date(entry.timestamp).getTime()
      const npcResponse = allMessages.find(msg => {
        if (msg.from === 'player' || usedMessageIds.has(msg.id)) return false
        const msgTime = new Date(msg.timestamp).getTime()
        return msgTime >= entryTime && msgTime <= entryTime + 5000 // Within 5 seconds
      })
      
      if (npcResponse) {
        timelineEntry.attachments.push({
          type: 'npc-response',
          npc: npcResponse.npc,
          content: npcResponse.content
        })
        usedMessageIds.add(npcResponse.id)
      }
    }
    
    // Check if this is a ticket note action - attach the note content
    if (entry.type === 'note' && entry.message.includes('ticket')) {
      const ticketIdMatch = entry.message.match(/ticket (TKT-\d+)/)
      if (ticketIdMatch) {
        const ticketId = ticketIdMatch[1]
        if (ticketNotes[ticketId] && !usedNoteTicketIds.has(ticketId)) {
          const ticket = allTickets.find(t => t.id === ticketId)
          // Format notes array into readable text
          const notesText = formatNotesArray(ticketNotes[ticketId])
          timelineEntry.attachments.push({
            type: 'ticket-note',
            ticketId,
            ticketSubject: ticket?.subject || 'Unknown',
            content: notesText
          })
          usedNoteTicketIds.add(ticketId)
        }
      }
    }
    
    // Check if this is an alert note action - attach the note content
    if (entry.type === 'note' && entry.message.includes('alert')) {
      const alertIdMatch = entry.message.match(/alert ([A-Z]-\d+)/)
      if (alertIdMatch) {
        const alertId = alertIdMatch[1]
        if (alertNotes[alertId] && !usedNoteAlertIds.has(alertId)) {
          const alert = allAlerts.find(a => a.id === alertId)
          // Format notes array into readable text
          const notesText = formatNotesArray(alertNotes[alertId])
          timelineEntry.attachments.push({
            type: 'alert-note',
            alertId,
            alertTitle: alert?.title || 'Unknown',
            content: notesText
          })
          usedNoteAlertIds.add(alertId)
        }
      }
    }
    
    timeline.push(timelineEntry)
  })
  
  // Add any evidence that wasn't matched to an action (shouldn't happen, but safety net)
  unlockedEvidence.forEach(ev => {
    if (!usedEvidenceIds.has(ev.id)) {
      timeline.push({
        type: 'evidence',
        gameTime: '??:??',
        realTime: '',
        message: `Evidence collected: ${ev.title}`,
        attachments: [{ type: 'evidence', data: ev }]
      })
    }
  })
  
  return timeline
}

function renderTimelineEntry(entry) {
  const typeStyles = {
    system: { icon: '‚öôÔ∏è', color: '#888' },
    token: { icon: 'ü™ô', color: '#4a9eff' },
    action: { icon: '‚ñ∂Ô∏è', color: '#333' },
    event: { icon: 'üì¢', color: '#f59e0b' },
    comms: { icon: 'üí¨', color: '#3b82f6' },
    evidence: { icon: 'üìÅ', color: '#22c55e' },
    note: { icon: 'üìù', color: '#8b5cf6' },
    containment: { icon: 'üõë', color: '#ef4444' },
    assessment: { icon: '‚úÖ', color: '#a855f7' }
  }
  
  const style = typeStyles[entry.type] || { icon: '‚Ä¢', color: '#333' }
  
  let html = `
    <div style="margin-bottom: 16px; page-break-inside: avoid;">
      <!-- Entry header -->
      <div style="display: flex; align-items: flex-start; gap: 12px;">
        <div style="font-size: 18px; line-height: 1;">${style.icon}</div>
        <div style="flex: 1;">
          <div style="display: flex; gap: 12px; margin-bottom: 4px;">
            <span style="font-family: monospace; font-size: 12px; color: #666; background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">${entry.gameTime}</span>
            <span style="font-size: 12px; color: #999;">${entry.realTime}</span>
          </div>
          <div style="color: ${style.color}; font-size: 14px;">${escapeHtml(entry.message)}</div>
        </div>
      </div>
  `
  
  // Render attachments
  if (entry.attachments && entry.attachments.length > 0) {
    html += `<div style="margin-left: 30px; margin-top: 10px;">`
    
    entry.attachments.forEach(att => {
      if (att.type === 'evidence') {
        html += `
          <div style="background: #f0fdf4; border-left: 3px solid #22c55e; padding: 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;">
            <div style="font-weight: 600; font-size: 13px; color: #166534; margin-bottom: 8px;">
              üìÅ ${escapeHtml(att.data.id)}: ${escapeHtml(att.data.title)}
            </div>
            <div style="font-size: 11px; color: #666; margin-bottom: 8px;">Category: ${escapeHtml(att.data.category)}</div>
            <pre style="background: #fff; padding: 10px; border-radius: 4px; font-size: 10px; white-space: pre-wrap; word-wrap: break-word; margin: 0; border: 1px solid #dcfce7;">${escapeHtml(att.data.content)}</pre>
          </div>
        `
      } else if (att.type === 'player-message') {
        html += `
          <div style="background: #eff6ff; border-left: 3px solid #3b82f6; padding: 10px 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;">
            <div style="font-size: 11px; color: #1e40af; margin-bottom: 4px;">Your message:</div>
            <div style="font-size: 12px; white-space: pre-wrap;">${escapeHtml(att.content)}</div>
          </div>
        `
      } else if (att.type === 'npc-response') {
        html += `
          <div style="background: #fefce8; border-left: 3px solid #eab308; padding: 10px 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;">
            <div style="font-size: 11px; color: #854d0e; margin-bottom: 4px;">${att.npc?.avatar || 'üë§'} ${escapeHtml(att.npc?.name || 'NPC')} responded:</div>
            <div style="font-size: 12px; white-space: pre-wrap;">${escapeHtml(att.content)}</div>
          </div>
        `
      } else if (att.type === 'ticket-note') {
        html += `
          <div style="background: #faf5ff; border-left: 3px solid #a855f7; padding: 10px 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;">
            <div style="font-size: 11px; color: #6b21a8; margin-bottom: 4px;">üìù Notes on ${escapeHtml(att.ticketId)} (${escapeHtml(att.ticketSubject)}):</div>
            <div style="font-size: 12px; white-space: pre-wrap;">${escapeHtml(att.content)}</div>
          </div>
        `
      } else if (att.type === 'alert-note') {
        html += `
          <div style="background: #fef3c7; border-left: 3px solid #f59e0b; padding: 10px 12px; margin-bottom: 10px; border-radius: 0 4px 4px 0;">
            <div style="font-size: 11px; color: #92400e; margin-bottom: 4px;">üìù Notes on ${escapeHtml(att.alertId)} (${escapeHtml(att.alertTitle)}):</div>
            <div style="font-size: 12px; white-space: pre-wrap;">${escapeHtml(att.content)}</div>
          </div>
        `
      }
    })
    
    html += `</div>`
  }
  
  html += `</div>`
  return html
}

function formatNotesArray(notes) {
  if (!notes || !Array.isArray(notes)) return ''
  return notes.map(note => {
    const time = new Date(note.timestamp).toLocaleTimeString('en-AU', { hour: '2-digit', minute: '2-digit' })
    return `[${time}] ${note.text}`
  }).join('\n')
}

function escapeHtml(text) {
  if (!text) return ''
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}
